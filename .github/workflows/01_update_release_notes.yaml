name: Update Release Notes on Release Event

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'info'
        type: choice
        options:
          - info
          - warning
          - debug
      environment:
        description: 'Environment to run in'
        type: environment
        required: true
      process_all_releases:
        description: 'Process all releases (including past ones)'
        required: false
        default: false
        type: boolean
      branch:
        description: 'Branch to use'
        required: true
        default: 'gh-pages'
      release_tag:
        description: 'Input release tag'
        required: true
        type: text

jobs:
  update-release-notes:
    permissions:
      contents: write
      pull-requests: write
      id-token: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: gh-pages
        
      - name: Install GitHub CLI and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y gh jq

      - name: Set release tag for release_event
        if: github.event_name == 'release'
        id: set_release_tag
        run: |
          RELEASE_TAG="${{ github.event.release.tag_name }}"
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set release tag for Wrokflow Event
        if: github.event_name == 'workflow_dispatch' && github.event.inputs.release_tag != ''
        id: set_workflow_release_tag
        run: |
          # Extract version from branch name (e.g., release-v1.2.3 -> v1.2.3)
          RELEASE_TAG="${{github.event.inputs.release_tag}}"
          echo "RELEASE_TAG=$RELEASE_TAG" >> $GITHUB_OUTPUT

      - name: Get latest release info
        id: latest_release
        run: |
          RELEASE_JSON=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${{ github.repository }}/releases/latest")
          LATEST_RELEASE_NAME=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
          IS_LATEST=$(echo "$RELEASE_JSON" | jq -r '.prerelease')
          echo "Latest release name: $LATEST_RELEASE_NAME"
          echo "Is latest release: $IS_LATEST"
          echo "LATEST_RELEASE_NAME=$LATEST_RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "IS_LATEST=$IS_LATEST" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: Generate release notes
        id: generate_notes
        run: |
          # Get the release tag from the appropriate step
          if [[ "${{ github.event_name }}" == "release" ]]; then
            RELEASE_TAG="${{ steps.set_release_tag.outputs.RELEASE_TAG }}"
          else
            RELEASE_TAG="${{ steps.set_workflow_release_tag.outputs.RELEASE_TAG }}"
          fi
          
          FILE_NAME="docs/src/content/docs/release_docs/$RELEASE_TAG.md"

          RELEASE_NOTES=$(gh release view $RELEASE_TAG --json body --template {{.body}})

          echo "Release Notes:\n$RELEASE_NOTES"

          # Check if RELEASE_NOTES is empty
          if [ -z "$RELEASE_NOTES" ]; then
            echo "No release notes found for $RELEASE_TAG. Skipping file update."
            echo "SKIP_UPDATE=true" >> $GITHUB_OUTPUT
            exit 0  # Exit gracefully without failing the action
          fi
          
          # Fetch changes from origin and prune stale remote tracking branches
          git fetch origin --prune
          
          # Get the commits specific to this release branch since the last release (tag)
          # Assumes tags are named v1.2.3, v2.0.0, etc.  Adjust if your tagging scheme is different.
          git fetch --tags

          # Get the commits specific to this release branch since the last release (tag)
          # Assumes tags are named v1.2.3, v2.0.0, etc.  Adjust if your tagging scheme is different.
          LAST_TAG=$(git describe --tags --abbrev=0 --match "v*"  $(git rev-list --tags --max-count=1))

          if [[ -z "$LAST_TAG" ]]; then
            echo "No previous release tag found!  Using the initial commit."
            #If you are working on a repo with no initial release, you need to add a commit message.
            LAST_TAG=$RELEASE_TAG
          fi
          
          # Update version references in documentation files
          if [ -f "docs/src/content/docs/introduction/getting_started.mdx" ]; then
            sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/introduction/getting_started.mdx
          fi
          if [ -f "docs/src/components/githubRelease.astro" ]; then
            sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/components/githubRelease.astro
          fi
          if [ -f "docs/src/content/docs/index.mdx" ]; then
            sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/index.mdx
          fi

          # Create directory if it doesn't exist
          mkdir -p "$(dirname "$FILE_NAME")"

          # Add a header to the file
          echo "---" > "$FILE_NAME"
          echo "title:  $RELEASE_TAG" >> "$FILE_NAME"
          echo "description: Release Notes for $RELEASE_TAG for vJailbreak" >> "$FILE_NAME"
          echo "---" >> "$FILE_NAME"
          echo "" >> "$FILE_NAME"
          # Append the new release notes to the file
          echo "$RELEASE_NOTES" >> "$FILE_NAME"

          echo "File updated: $FILE_NAME"
          echo "FILE_NAME=$FILE_NAME" >> $GITHUB_OUTPUT
          echo "SKIP_UPDATE=false" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: archive old release notes
        run: |
          echo "Checking for older release notes"
          # strip leading 'v', sort semantically, pick top-5, then subtract
          mapfile -t ALL < <(ls docs/src/content/docs/release_docs/v* 2>/dev/null | sed 's/^v//' | sort -V)
          mapfile -t TOP5 < <(printf '%s\n' "${ALL[@]}" | tail -n 5)

          # build a lookup for TOP5
          declare -A is_top5
          for v in "${TOP5[@]}"; do
            is_top5["$v"]=1
          done

          echo "Top 5 versions"
          for v in "${TOP5[@]}"; do
            echo "v$v"
          done

          echo "Archived versions"
          for v in "${ALL[@]}"; do
            if [[ -z "${is_top5[$v]}" ]]; then
              echo "trying to archive v$v"
              awk '
              BEGIN { in_yaml=0 }
              # Toggle YAML block
              /^---$/ {
              in_yaml = !in_yaml
              next
              }

              # While inside YAML block
              in_yaml {
              if ($1 == "title:") {
              sub(/^title:[[:space:]]*v/, "## v")
              print
              }
              next
              }

              # Outside YAML: convert all ## to ###
              {
              sub(/^##/, "###")
              print
              }
              ' docs/src/content/docs/release_docs/v$v.md >> docs/src/content/docs/archives/release_notes.md
            fi 
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}    

      - name: Create PR with changes
        if: steps.generate_notes.outputs.SKIP_UPDATE != 'true'
        run: |
          # Configure Git
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions Bot"

          # Get the release tag from the appropriate step
          if [[ "${{ github.event_name }}" == "release" ]]; then
            RELEASE_TAG="${{ steps.set_release_tag.outputs.RELEASE_TAG }}"
          else
            RELEASE_TAG="${{ steps.set_workflow_release_tag.outputs.RELEASE_TAG }}"
          fi

          # Create a new branch
          NEW_BRANCH="update-release-notes-$RELEASE_TAG"

          git checkout -b $NEW_BRANCH

          # Add and commit changes
          git add docs/src/content/docs/*
          git commit -m "Update release notes for $RELEASE_TAG"

          # Push the new branch
          git push origin $NEW_BRANCH

          # Create a pull request
          gh pr create --base gh-pages --head $NEW_BRANCH --title "Update release notes for $RELEASE_TAG" --body "Automatically generated PR to update release notes"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

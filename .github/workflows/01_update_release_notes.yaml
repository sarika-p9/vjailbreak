name: Update Release Notes on Release Event

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      logLevel:
        description: 'Log level'
        required: true
        default: 'info'
        type: choice
        options:
          - info
          - warning
          - debug
      environment:
        description: 'Environment to run in'
        type: environment
        required: true
      process_all_releases:
        description: 'Process all releases (including past ones)'
        required: false
        default: false
        type: boolean
      branch:
        description: 'Branch to use'
        required: true
        default: 'gh-pages'
      release_tag:
        description: 'Input release tag'
        required: true
        type: text

jobs:
  update-release-notes:
    permissions:
      contents: write
      pull-requests: write
      id-token: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: gh-pages
        
      - name: Install GitHub CLI and jq
        run: |
          sudo apt-get update
          sudo apt-get install -y gh jq

      - name: Process and Generate Release Notes
        id: process_releases
        run: |
          # This function processes a single release tag
          process_release() {
            local RELEASE_TAG=$1
            
            # For manual runs, skip if the doc file already exists
            if [[ "${{ github.event.inputs.process_all_releases }}" == "true" ]]; then
              if [ -f "docs/src/content/docs/release_docs/$RELEASE_TAG.md" ]; then
                echo "Documentation already exists for $RELEASE_TAG, skipping."
                return 0
              fi
            fi

            echo "Processing release: $RELEASE_TAG"
            RELEASE_NOTES=$(gh release view $RELEASE_TAG --json body --template '{{.body}}' || echo "")
            
            if [ -z "$RELEASE_NOTES" ]; then
              echo "No release notes found for $RELEASE_TAG, skipping."
              return 0
            fi

            # Find the tag immediately before this one
            LAST_TAG=$(git describe --tags --abbrev=0 --match "v*" "$RELEASE_TAG^" 2>/dev/null || echo "")
            
            # Update version numbers in docs if a previous tag was found
            if [[ -n "$LAST_TAG" && "$LAST_TAG" != "$RELEASE_TAG" ]]; then
              echo "Replacing version string '$LAST_TAG' with '$RELEASE_TAG' in docs."
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/introduction/getting_started.mdx 2>/dev/null || true
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/components/githubRelease.astro 2>/dev/null || true
              sed -i "s|$LAST_TAG|$RELEASE_TAG|g" docs/src/content/docs/index.mdx 2>/dev/null || true
            fi

            # Create the release note .md file
            FILE_NAME="docs/src/content/docs/release_docs/$RELEASE_TAG.md"
            mkdir -p "$(dirname "$FILE_NAME")"
            {
              echo "---"
              echo "title:  $RELEASE_TAG"
              echo "description: Release Notes for $RELEASE_TAG for vJailbreak"
              echo "---"
              echo ""
              echo "$RELEASE_NOTES"
            } > "$FILE_NAME"
            
            echo "Created documentation for $RELEASE_TAG"
            # Add the processed tag to the output
            PROCESSED_LIST_TEMP+="$RELEASE_TAG "
          }

          # Make the function available to subshells
          export -f process_release
          # Fetch all tags from the repository
          git fetch --tags --prune
          
          PROCESSED_LIST_TEMP=""

          # This is the main logic block
          # If "process_all_releases" is checked in a manual run...
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && "${{ github.event.inputs.process_all_releases }}" == "true" ]]; then
            echo "Processing all recent missing releases..."
            # Get all release tags, sort them by version
            ALL_RELEASES=$(gh release list --limit 50 --json tagName --jq '.[].tagName' | sort -V)
            
            # Loop through all releases and process each one
            for TAG in $ALL_RELEASES; do
              process_release "$TAG"
            done
          # If triggered by a new published release...
          elif [[ "${{ github.event_name }}" == "release" ]]; then
            echo "Processing single new release..."
            process_release "${{ github.event.release.tag_name }}"
          fi
          
          # Set the final output for the next step
          echo "PROCESSED_RELEASES=${PROCESSED_LIST_TEMP}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: Archive old release notes
        run: |
          echo "Checking for older release notes..."
          mapfile -t ALL_VERSIONS < <(find docs/src/content/docs/release_docs -name "v*.md" -printf "%f\n" | sed -e 's/^v//' -e 's/\.md$//' | sort -V)
          mapfile -t TOP5 < <(printf '%s\n' "${ALL_VERSIONS[@]}" | tail -n 5)

          declare -A is_top5
          for v in "${TOP5[@]}"; do is_top5["$v"]=1; done

          echo "Top 5 versions:"
          printf 'v%s\n' "${TOP5[@]}"

          for v in "${ALL_VERSIONS[@]}"; do
            if [[ -z "${is_top5[$v]}" ]]; then
              FILE_TO_ARCHIVE="docs/src/content/docs/release_docs/v${v}.md"
              echo "Archiving $FILE_TO_ARCHIVE"
              # Your awk command here...
              awk 'BEGIN { in_yaml=0 } /^---$/ { in_yaml = !in_yaml; next } in_yaml { if ($1 == "title:") { sub(/^title:[[:space:]]*v/, "## v"); print; }; next; } { sub(/^##/, "###"); print }' "$FILE_TO_ARCHIVE" >> docs/src/content/docs/archives/release_notes.md
              # rm "$FILE_TO_ARCHIVE" # Optional: remove the file after archiving
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create PR with changes
        if: steps.process_releases.outputs.PROCESSED_RELEASES != ''
        run: |
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git config --global user.name "GitHub Actions Bot"
          
          TIMESTAMP=$(date +%s)
          PROCESSED_TAGS="${{ steps.process_releases.outputs.PROCESSED_RELEASES }}"
          NEW_BRANCH="update-release-notes-$TIMESTAMP"
          
          git checkout -b $NEW_BRANCH
          git add docs/src/content/docs/
          
          if ! git diff --cached --quiet; then
            git commit -m "docs: Update release notes for ${PROCESSED_TAGS}"
            git push origin $NEW_BRANCH
            gh pr create --base gh-pages --head $NEW_BRANCH --title "docs: Update release notes for ${PROCESSED_TAGS}" --body "Automatically generated PR to update release notes."
          else
            echo "No changes detected to create a pull request."
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
